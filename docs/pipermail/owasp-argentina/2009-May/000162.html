<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To=3f9007680905111854s37e4c45evc6fb18b5da8bc87f%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="000159.html">
   <LINK REL="Next"  HREF="000163.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas </H1>
    <B>Ezequiel Gutesman</B> 
    <A HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To=3f9007680905111854s37e4c45evc6fb18b5da8bc87f%40mail.gmail.com"
       TITLE="[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas">egutesman en gmail.com
       </A><BR>
    <I>Mar Mayo 12 11:15:15 EDT 2009</I>
    <P><UL>
        <LI>Mensaje anterior: <A HREF="000159.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
        <LI>Próximo mensaje: <A HREF="000163.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#162">[ fecha ]</a>
              <a href="thread.html#162">[ hilo ]</a>
              <a href="subject.html#162">[ asunto ]</a>
              <a href="author.html#162">[ autor ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Bueno como ya mande en un mail anterior, una solucion a la que de vez en
cuando le ponemos un poco de esfuerzo pero tenemos medio &quot;dormida&quot; es Grasp,
que es dinamio, en run-time.

Como a algunos ya les conte, hace un tiempo tuvimos una experiencia haciendo
una tool como la que decribe juanjo para java, trabajmos algunas personas de
Core y otras de la UNLP-LIFIA (en particular, un grupo especializado en
analisis estatico de codigo).

Muchos de los problemas que describis, los solucionamos, dando algunas
concesiones, entre lineas te contesto:

2009/5/11 Juanjo Conti &lt;<A HREF="https://lists.owasp.org/mailman/listinfo/owasp-argentina">jjconti en gmail.com</A>&gt;

&gt;<i> Lista,
</I>&gt;<i>
</I>&gt;<i> Para ayudarme con la explicación hice este dibujo:
</I>&gt;<i> <A HREF="http://juanjoconti.com.ar/files/Diagrama-taint.jpeg">http://juanjoconti.com.ar/files/Diagrama-taint.jpeg</A>
</I>&gt;<i>
</I>&gt;<i> La idea (general) que planteo a continuación está basada en las ideas
</I>&gt;<i> propuestas en la lista y material que estuve leyendo. Con lo siguiente no
</I>&gt;<i> pretendo plantear el esquema de una solución definitiva, sino ordenar mis
</I>&gt;<i> ideas y compartirlas para que me ayuden a ver los errores que puedo estar
</I>&gt;<i> cometiendo.
</I>&gt;<i>
</I>&gt;<i> Para encarar el problema de soportar distintos lenguajes de programación,
</I>&gt;<i> parece necesario pre procesar el código fuente para llevarlo a una forma
</I>&gt;<i> normal, independiente del lenguaje (por ejemplo TAC[0]). Una vez que se
</I>&gt;<i> tiene el programa en una forma normal este debe ser procesado para
</I>&gt;<i> encontrar
</I>&gt;<i> vulnerabilidades. A continuación planteo ideas para realizar este
</I>&gt;<i> procesamiento o análisis.
</I>&gt;<i>
</I>&gt;<i> Este proceso puede ser dinámico (ejecutando el programa) o estático
</I>&gt;<i> (analizando el código fuente). Analizar estáticamente tiene el problema de
</I>&gt;<i> la indecibilidad cuando existen condicionales dependientes de condiciones
</I>&gt;<i> externas. Un ejemplo burdo pero claro:
</I>&gt;<i>
</I>&gt;<i> a = entrada()
</I>&gt;<i> if (CONDICION NO CONTROLADA):
</I>&gt;<i>    a = limpiar(a)
</I>&gt;<i> else:
</I>&gt;<i>    otra cosa
</I>&gt;<i>
</I>&gt;<i> (En este caso no estaríamos seguro si después de este bloque de código la
</I>&gt;<i> variable a está manchada o no; opino que aquí como resultado hay que
</I>&gt;<i> dejarla
</I>&gt;<i> manchada. Un falso positivo es preferible a falso negativo).
</I>&gt;<i>
</I>
Sacar el &quot;supremo&quot; de las posibles soluciones para este problema es un
approach, esto impide que explote la cantidad de paths a explorar. Si tomas
un supremo y no bifurcas el analisis entonces no se te va al demonio la
complejidad del analisis.

A lo que me refiero con &quot;bifurcar&quot; es mirando el AST (ver
aca&lt;<A HREF="http://en.wikipedia.org/wiki/Abstract_syntax_tree">http://en.wikipedia.org/wiki/Abstract_syntax_tree</A>&gt;) (abstract
syntax tree) del programa, si abris el if, te queda la rama del
else y la rama del true, que pueden llegar a tener resultados y paths de
ejecucion totalemnte diferentes (imaginate un if mas grande, que controle el
flujo del programa)


&gt;<i> Por otro lado, para realizar un análisis dinámico, se requiere una batería
</I>&gt;<i> de datos especialmente preparada para realizar corridas con el programa y
</I>&gt;<i> detectar así posibles vulnerabilidades. Opino que le enfoque estático es
</I>&gt;<i> que
</I>&gt;<i> se alinea con las ideas planteadas en esta lista (particularmente, detectar
</I>&gt;<i> amenazas en tiempo de codificación). [1]
</I>&gt;<i>
</I>&gt;<i> Los parámetros de este procesamiento son 3 listas de funciones(+):
</I>&gt;<i>
</I>&gt;<i> - una lista de funciones de entradas; es decir fuentes desde dónde pueden
</I>&gt;<i> venir datos no confiables (por ejemplo, peticiones desde la red o archivos
</I>&gt;<i> locales).
</I>&gt;<i> - una lista de funciones limpiadoras o sanadoras (¿cual término es mejor?)
</I>&gt;<i> que convierte una variable manchada en una variable limpia (*).
</I>&gt;<i> - una lista de sumideros sensibles (sensitive sinks); lugares a dónde no
</I>&gt;<i> queremos que llegue una variable manchada, por que si lo hace estamos ante
</I>&gt;<i> una posible vulnerabilidad (por ejemplo, escritura en archivos, consulta a
</I>&gt;<i> bases de datos, envío de emails, construcción de respuestas html para el
</I>&gt;<i> usuario).
</I>&gt;<i>
</I>
Exacto. Tenes que tener cuidado, porque a veces las que definis como
sanadoras no son tan sanadoras (p.ej, una funcion definida por el usuario,
que sanitiza un user, la tomas como que sanitiza bien?, htmlspecialchars
sanitiza bien? depende...) ahi hay complicaciones.


&gt;<i>
</I>&gt;<i> Agrupo estas listas en el término &quot;parámetros&quot; por que las 3 son
</I>&gt;<i> dependientes del programa en concreto: de qué framework se use para
</I>&gt;<i> programar, de qué librerías, funciones de validación propias del equipo de
</I>&gt;<i> desarrollo. Por ejemplo: Django tiene sus funciones propias para limpiar
</I>&gt;<i> variables.
</I>&gt;<i>
</I>
Tambien depende, son como vos decis, decisiones.


&gt;<i>
</I>&gt;<i> (El usuario podría incluso ir agregando elementos a estas listas en tiempo
</I>&gt;<i> de codificación).
</I>&gt;<i>
</I>&gt;<i> Otra entrada que necesita este procesamiento (además del código fuente
</I>&gt;<i> normalizado y las tres listas de funciones) es un conjunto de modos o flags
</I>&gt;<i> que le indiquen como proceder. ¿A qué me refiero? Como no estoy seguro de
</I>&gt;<i> todos las cuestiones que caen aquí, pongo un ejemplo:
</I>&gt;<i>
</I>&gt;<i> En el lenguaje YYY las variables hacen referencia a un lugar en memoria y
</I>&gt;<i> soporta asignación por referencia.
</I>&gt;<i>
</I>&gt;<i> a = 1       // a vale 1
</I>&gt;<i> b &amp;= a     // b apunta al mismo lugar que a en la memoria
</I>&gt;<i> a = 2       // el valor de a y b cambian
</I>&gt;<i>
</I>&gt;<i> En el lenguaje ZZZ las variables son referencias a objetos.
</I>&gt;<i>
</I>&gt;<i> a = 1       // a apunta a 1
</I>&gt;<i> b = a       //  b apunta al mismo objeto que a
</I>&gt;<i> a = 2       // a punta al objeto 2 y b sigue apuntando al objeto 1
</I>&gt;<i>
</I>
Tambien nos encontramos con esto, lo resolvimos con un symbolic heap, es
decir (y aca muestor la hiclacha del tipo de analisis), durante el analisis
se hace una &quot;especie&quot; de ejecucion simbolica, donde se mantiene un heap
simbolico y otras cosas que describo luego.



&gt;<i>
</I>&gt;<i> En el primer lenguaje se soporta el concepto de &quot;alias&quot;, mientras que en el
</I>&gt;<i> segundo no. A la hora de realizar el análisis sobre un programa YYY es
</I>&gt;<i> necesario también un sub procedimiento que haga Alias Analysis; en un
</I>&gt;<i> programa ZZZ no hace falta. Si no se tiene el sub procedimiento para
</I>&gt;<i> análisis de alias, todo sigue funcionando. Pero es probable que en los
</I>&gt;<i> programas escritos en YYY se encuentren menos vulnerabilidades.
</I>&gt;<i>
</I>&gt;<i> Esto último es solo una idea intuitiva que tengo, si alguien puede arrojar
</I>&gt;<i> más luz al asunto se lo agradezco. Por otro lado, puede ser que la solución
</I>&gt;<i> de este tipo de problemas/incompatibilidades sea correcto realizarla en el
</I>&gt;<i> paso previo (Normalización). No lo se, no lo veo claro aún.
</I>&gt;<i>
</I>
Es bastante dificil normalizar y resolver aliasing, es todo un analisis
aparte, pero se puede.


&gt;<i>
</I>&gt;<i> Me imagino que deben existir otros problemas dependientes del lenguaje que
</I>&gt;<i> requieran de sub procedimientos específicos; agrupo esto en el concepto de
</I>&gt;<i> &quot;modo&quot;. Un modo estaría definido por el conjunto de sub analizadores que
</I>&gt;<i> carga antes de correr.
</I>&gt;<i>
</I>
otro problema es el de las iteraciones. Dentro de un loop el estado de las
variables (en terminos de sanidad) puede cambiar. Para eso, en la misma
ejecucion simbolica realizamos una busqueda de &quot;punto fijo&quot; es decir, un
punto en el cual el estado de sanidad de las variabels no cambia mas. Una
vez encontrado, se deja ese valo. te doy un ejemplo (de PHP):

$a = $_POST[&quot;sarasa&quot;];
while (&lt;condicion&gt;)
{
   $b = $a;
   $c = $d;
   $a = $d;

}

ponele, si este while loopea una sola vez, $a y $b salen manchadas, si
loopea mas, limpia (suponiendo $d limpia). Estos casos se pueden poner mas
complejos.


&gt;<i>
</I>&gt;<i> Este procesamiento puede realizarse mediante Data Flow Analysis (esta
</I>&gt;<i> técnica, es utilizada por Pixy y documentada en [2]).
</I>&gt;<i>
</I>
si, se llama asi o Information Flow tb.


&gt;<i> También se puede utilizar otra técnica; ¿conocen alguna otra teoría
</I>&gt;<i> aplicable? Otro disparador para investigar.
</I>&gt;<i>
</I>
Si, hay tecnicas basadas en gramaticas pero exploramos ese campo y es
muchisimo mas dificil, aunque mas preciso. Pablo Martinez Lopez laburo con
nosotros y estaba siguiendo esta linea:

<A HREF="http://www.exactas.org/modules/UpDownload/store_folder/LCC/AnalisisEstaticoParaDetectarVulnerabilidades.ppt">http://www.exactas.org/modules/UpDownload/store_folder/LCC/AnalisisEstaticoParaDetectarVulnerabilidades.ppt</A>


Espero sirva para orientarte.

salu2
gutes
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensaje anterior: <A HREF="000159.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
	<LI>Próximo mensaje: <A HREF="000163.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#162">[ fecha ]</a>
              <a href="thread.html#162">[ hilo ]</a>
              <a href="subject.html#162">[ asunto ]</a>
              <a href="author.html#162">[ autor ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.owasp.org/mailman/listinfo/owasp-argentina">Más información sobre la lista de distribución Owasp-argentina </a><br>
</body></html>
