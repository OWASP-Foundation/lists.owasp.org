<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="000161.html">
   <LINK REL="Next"  HREF="000162.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas </H1>
    <B>Juanjo Conti</B> 
    <A HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To="
       TITLE="[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas">jjconti en gmail.com
       </A><BR>
    <I>Lun Mayo 11 21:54:04 EDT 2009</I>
    <P><UL>
        <LI>Mensaje anterior: <A HREF="000161.html">[Owasp-argentina] Vulnerabilidades de variables manchadas
</A></li>
        <LI>Próximo mensaje: <A HREF="000162.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#159">[ fecha ]</a>
              <a href="thread.html#159">[ hilo ]</a>
              <a href="subject.html#159">[ asunto ]</a>
              <a href="author.html#159">[ autor ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Lista,

Para ayudarme con la explicación hice este dibujo:
<A HREF="http://juanjoconti.com.ar/files/Diagrama-taint.jpeg">http://juanjoconti.com.ar/files/Diagrama-taint.jpeg</A>

La idea (general) que planteo a continuación está basada en las ideas
propuestas en la lista y material que estuve leyendo. Con lo siguiente no
pretendo plantear el esquema de una solución definitiva, sino ordenar mis
ideas y compartirlas para que me ayuden a ver los errores que puedo estar
cometiendo.

Para encarar el problema de soportar distintos lenguajes de programación,
parece necesario pre procesar el código fuente para llevarlo a una forma
normal, independiente del lenguaje (por ejemplo TAC[0]). Una vez que se
tiene el programa en una forma normal este debe ser procesado para encontrar
vulnerabilidades. A continuación planteo ideas para realizar este
procesamiento o análisis.

Este proceso puede ser dinámico (ejecutando el programa) o estático
(analizando el código fuente). Analizar estáticamente tiene el problema de
la indecibilidad cuando existen condicionales dependientes de condiciones
externas. Un ejemplo burdo pero claro:

a = entrada()
if (CONDICION NO CONTROLADA):
    a = limpiar(a)
else:
    otra cosa

(En este caso no estaríamos seguro si después de este bloque de código la
variable a está manchada o no; opino que aquí como resultado hay que dejarla
manchada. Un falso positivo es preferible a falso negativo).

Por otro lado, para realizar un análisis dinámico, se requiere una batería
de datos especialmente preparada para realizar corridas con el programa y
detectar así posibles vulnerabilidades. Opino que le enfoque estático es que
se alinea con las ideas planteadas en esta lista (particularmente, detectar
amenazas en tiempo de codificación). [1]

Los parámetros de este procesamiento son 3 listas de funciones(+):

- una lista de funciones de entradas; es decir fuentes desde dónde pueden
venir datos no confiables (por ejemplo, peticiones desde la red o archivos
locales).
- una lista de funciones limpiadoras o sanadoras (¿cual término es mejor?)
que convierte una variable manchada en una variable limpia (*).
- una lista de sumideros sensibles (sensitive sinks); lugares a dónde no
queremos que llegue una variable manchada, por que si lo hace estamos ante
una posible vulnerabilidad (por ejemplo, escritura en archivos, consulta a
bases de datos, envío de emails, construcción de respuestas html para el
usuario).

Agrupo estas listas en el término &quot;parámetros&quot; por que las 3 son
dependientes del programa en concreto: de qué framework se use para
programar, de qué librerías, funciones de validación propias del equipo de
desarrollo. Por ejemplo: Django tiene sus funciones propias para limpiar
variables.

(El usuario podría incluso ir agregando elementos a estas listas en tiempo
de codificación).

Otra entrada que necesita este procesamiento (además del código fuente
normalizado y las tres listas de funciones) es un conjunto de modos o flags
que le indiquen como proceder. ¿A qué me refiero? Como no estoy seguro de
todos las cuestiones que caen aquí, pongo un ejemplo:

En el lenguaje YYY las variables hacen referencia a un lugar en memoria y
soporta asignación por referencia.

a = 1       // a vale 1
b &amp;= a     // b apunta al mismo lugar que a en la memoria
a = 2       // el valor de a y b cambian

En el lenguaje ZZZ las variables son referencias a objetos.

a = 1       // a apunta a 1
b = a       //  b apunta al mismo objeto que a
a = 2       // a punta al objeto 2 y b sigue apuntando al objeto 1

En el primer lenguaje se soporta el concepto de &quot;alias&quot;, mientras que en el
segundo no. A la hora de realizar el análisis sobre un programa YYY es
necesario también un sub procedimiento que haga Alias Analysis; en un
programa ZZZ no hace falta. Si no se tiene el sub procedimiento para
análisis de alias, todo sigue funcionando. Pero es probable que en los
programas escritos en YYY se encuentren menos vulnerabilidades.

Esto último es solo una idea intuitiva que tengo, si alguien puede arrojar
más luz al asunto se lo agradezco. Por otro lado, puede ser que la solución
de este tipo de problemas/incompatibilidades sea correcto realizarla en el
paso previo (Normalización). No lo se, no lo veo claro aún.

Me imagino que deben existir otros problemas dependientes del lenguaje que
requieran de sub procedimientos específicos; agrupo esto en el concepto de
&quot;modo&quot;. Un modo estaría definido por el conjunto de sub analizadores que
carga antes de correr.

Este procesamiento puede realizarse mediante Data Flow Analysis (esta
técnica, es utilizada por Pixy y documentada en [2]).

También se puede utilizar otra técnica; ¿conocen alguna otra teoría
aplicable? Otro disparador para investigar.

¿Qué les parece?

(+) funciones, objetos, lo que sea.
(*) aquí hay un punto que podemos dejarlo para más adelante: no todas las
funciones limpiadoras proveen de todas las posibles amenazas. Una función
que convierte los caracteres &lt; y &gt; en &amp;lt; y &amp;gt; puede prevenir XSS pero no
SQLI.

[0] Tree-address code; es la única que conozco pero no me convenció aún.
Abría que buscar otras. Este es un disparador a investigar.
[1] En Implementation of Tainted Mode approach to finding security
vulnerabilities for Python technology se plantea cómo implementar un
análisis dinámico en Python.
<A HREF="http://syrcose.ispras.ru/2007/files/2007_07_paper.pdf">http://syrcose.ispras.ru/2007/files/2007_07_paper.pdf</A>
[2] Pixy: A Static Analysis Tool for Detecting Web Application
Vulnerabilities (Technical Report).
<A HREF="http://www.seclab.tuwien.ac.at/papers/pixy_techreport.pdf">http://www.seclab.tuwien.ac.at/papers/pixy_techreport.pdf</A>

-- 
Juanjo Conti
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensaje anterior: <A HREF="000161.html">[Owasp-argentina] Vulnerabilidades de variables manchadas
</A></li>
	<LI>Próximo mensaje: <A HREF="000162.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#159">[ fecha ]</a>
              <a href="thread.html#159">[ hilo ]</a>
              <a href="subject.html#159">[ asunto ]</a>
              <a href="author.html#159">[ autor ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.owasp.org/mailman/listinfo/owasp-argentina">Más información sobre la lista de distribución Owasp-argentina </a><br>
</body></html>
