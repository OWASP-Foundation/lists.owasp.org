<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To=3f9007680905111854s37e4c45evc6fb18b5da8bc87f%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="000162.html">
   <LINK REL="Next"  HREF="000164.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas </H1>
    <B>Andres Riancho</B> 
    <A HREF="mailto:owasp-argentina%40lists.owasp.org?Subject=%5BOwasp-argentina%5D%20Sistema%20para%20detectar%20vulnerabilidades%20de%0A%09variables%20manchadas&In-Reply-To=3f9007680905111854s37e4c45evc6fb18b5da8bc87f%40mail.gmail.com"
       TITLE="[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas">andres.riancho en gmail.com
       </A><BR>
    <I>Mar Mayo 12 12:54:51 EDT 2009</I>
    <P><UL>
        <LI>Mensaje anterior: <A HREF="000162.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
        <LI>Próximo mensaje: <A HREF="000164.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#163">[ fecha ]</a>
              <a href="thread.html#163">[ hilo ]</a>
              <a href="subject.html#163">[ asunto ]</a>
              <a href="author.html#163">[ autor ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Juanjo,

2009/5/11 Juanjo Conti &lt;<A HREF="https://lists.owasp.org/mailman/listinfo/owasp-argentina">jjconti en gmail.com</A>&gt;:
&gt;<i> Lista,
</I>&gt;<i>
</I>&gt;<i> Para ayudarme con la explicación hice este dibujo:
</I>&gt;<i> <A HREF="http://juanjoconti.com.ar/files/Diagrama-taint.jpeg">http://juanjoconti.com.ar/files/Diagrama-taint.jpeg</A>
</I>
Se ve bien,

&gt;<i> La idea (general) que planteo a continuación está basada en las ideas
</I>&gt;<i> propuestas en la lista y material que estuve leyendo. Con lo siguiente no
</I>&gt;<i> pretendo plantear el esquema de una solución definitiva, sino ordenar mis
</I>&gt;<i> ideas y compartirlas para que me ayuden a ver los errores que puedo estar
</I>&gt;<i> cometiendo.
</I>&gt;<i>
</I>&gt;<i> Para encarar el problema de soportar distintos lenguajes de programación,
</I>&gt;<i> parece necesario pre procesar el código fuente para llevarlo a una forma
</I>&gt;<i> normal, independiente del lenguaje (por ejemplo TAC[0]). Una vez que se
</I>&gt;<i> tiene el programa en una forma normal este debe ser procesado para encontrar
</I>&gt;<i> vulnerabilidades. A continuación planteo ideas para realizar este
</I>&gt;<i> procesamiento o análisis.
</I>&gt;<i>
</I>&gt;<i> Este proceso puede ser dinámico (ejecutando el programa) o estático
</I>&gt;<i> (analizando el código fuente). Analizar estáticamente tiene el problema de
</I>&gt;<i> la indecibilidad cuando existen condicionales dependientes de condiciones
</I>&gt;<i> externas. Un ejemplo burdo pero claro:
</I>
Creo que &quot;ejecutarlo&quot; no es una buena idea,

&gt;<i> a = entrada()
</I>&gt;<i> if (CONDICION NO CONTROLADA):
</I>&gt;<i>    a = limpiar(a)
</I>&gt;<i> else:
</I>&gt;<i>    otra cosa
</I>&gt;<i>
</I>&gt;<i> (En este caso no estaríamos seguro si después de este bloque de código la
</I>&gt;<i> variable a está manchada o no; opino que aquí como resultado hay que dejarla
</I>&gt;<i> manchada. Un falso positivo es preferible a falso negativo).
</I>
Yo pondría un listado que va siguiendo a la variable por todos lados,
de manera que sea algo así:

1:    a = entrada()
2:    if (CONDICION NO CONTROLADA):
3:       a = limpiar(a)
4:    else:
5:       otra cosa

==&gt; variables = {a: &lt;tainted if not CONDICION NO CONTROLADA&gt;}

6:    if (CONDICION NO CONTROLADA 2):
7:       a = limpiar(a)
8:    else:
9:       otra cosa

==&gt; variables = {a: &lt;tainted if not CONDICION NO CONTROLADA and not
CONDICION NO CONTROLADA2&gt;}

&gt;<i> Por otro lado, para realizar un análisis dinámico, se requiere una batería
</I>&gt;<i> de datos especialmente preparada para realizar corridas con el programa y
</I>&gt;<i> detectar así posibles vulnerabilidades. Opino que le enfoque estático es que
</I>&gt;<i> se alinea con las ideas planteadas en esta lista (particularmente, detectar
</I>&gt;<i> amenazas en tiempo de codificación). [1]
</I>
En mi mente, ni se me ocurre como hacerlo de manera dinamica sin
&quot;hookear en PHP&quot; tal como hacen los muchachos con GRASP.

&gt;<i> Los parámetros de este procesamiento son 3 listas de funciones(+):
</I>&gt;<i>
</I>&gt;<i> - una lista de funciones de entradas; es decir fuentes desde dónde pueden
</I>&gt;<i> venir datos no confiables (por ejemplo, peticiones desde la red o archivos
</I>&gt;<i> locales).
</I>
Si,

&gt;<i> - una lista de funciones limpiadoras o sanadoras (¿cual término es mejor?)
</I>&gt;<i> que convierte una variable manchada en una variable limpia (*).
</I>
Si, pero aca yo lo abriría en varias partes. Basicamente... QUE
limpian? Puede ser que una funcion limpiadora, limpie algo que se
encuentra manchado en el contexto de un XSS, pero no en el contexto de
una inyección SQL. Ejemplos de algo mal armado:

1:    $a = $_GET['a'];
2:    $a = limpiador_anti_xss($a);

Acá, si solo mantenes el estado de &quot;manchado/no manchado&quot;, la variable
pasa a estar no manchada, pero si despues se usa así?

3:    mysql_query('SELECT * from table where id=' . $a);

Creo que en la parte de tainted, al inicio (linea uno) deberías poner
que esta TOTALMENTE manchado, y luego debes poner que en la línea dos
se desmancha para XSS, pero el resto de los flags de manchado deben
seguir estando ahí! (por ejemplo, el flag de manchado para SQL
injection que es el que aplica en este caso)

&gt;<i> - una lista de sumideros sensibles (sensitive sinks); lugares a dónde no
</I>&gt;<i> queremos que llegue una variable manchada, por que si lo hace estamos ante
</I>&gt;<i> una posible vulnerabilidad (por ejemplo, escritura en archivos, consulta a
</I>&gt;<i> bases de datos, envío de emails, construcción de respuestas html para el
</I>&gt;<i> usuario).
</I>
Ok, aca aplica lo mismo. Si a una función como mysql_query, le llega
algo que esta manchado para XSS, pero no para SQL injection, entonces
no va a haber una inyección SQL.

&gt;<i> Agrupo estas listas en el término &quot;parámetros&quot; por que las 3 son
</I>&gt;<i> dependientes del programa en concreto: de qué framework se use para
</I>&gt;<i> programar, de qué librerías, funciones de validación propias del equipo de
</I>&gt;<i> desarrollo. Por ejemplo: Django tiene sus funciones propias para limpiar
</I>&gt;<i> variables.
</I>
Si, yo creo que esta bien la agrupación. Creo que lo que va a quedar
muy bien para esto es armar algo en XML, que defina para cada lenguaje
de programación / framework, cuales son las funciones y cosas a tener
en cuenta. Algo interesante a plantear es que la definición en XML de
un framework debería heredar de la definición del lenguage de
programación.

&gt;<i> (El usuario podría incluso ir agregando elementos a estas listas en tiempo
</I>&gt;<i> de codificación).
</I>
Si, exacto. Las herramientas comerciales permiten hacer esto, para que
si vos de repente armas una función para validar enteros, y la llamas
&quot;validate_pepe_int&quot;, esto pueda ser comprendido por el analizador de
código y te sanitice correctamente todo.

&gt;<i> Otra entrada que necesita este procesamiento (además del código fuente
</I>&gt;<i> normalizado y las tres listas de funciones) es un conjunto de modos o flags
</I>&gt;<i> que le indiquen como proceder. ¿A qué me refiero? Como no estoy seguro de
</I>&gt;<i> todos las cuestiones que caen aquí, pongo un ejemplo:
</I>&gt;<i>
</I>&gt;<i> En el lenguaje YYY las variables hacen referencia a un lugar en memoria y
</I>&gt;<i> soporta asignación por referencia.
</I>&gt;<i>
</I>&gt;<i> a = 1       // a vale 1
</I>&gt;<i> b &amp;= a     // b apunta al mismo lugar que a en la memoria
</I>&gt;<i> a = 2       // el valor de a y b cambian
</I>&gt;<i>
</I>&gt;<i> En el lenguaje ZZZ las variables son referencias a objetos.
</I>&gt;<i>
</I>&gt;<i> a = 1       // a apunta a 1
</I>&gt;<i> b = a       //  b apunta al mismo objeto que a
</I>&gt;<i> a = 2       // a punta al objeto 2 y b sigue apuntando al objeto 1
</I>&gt;<i>
</I>&gt;<i> En el primer lenguaje se soporta el concepto de &quot;alias&quot;, mientras que en el
</I>&gt;<i> segundo no. A la hora de realizar el análisis sobre un programa YYY es
</I>&gt;<i> necesario también un sub procedimiento que haga Alias Analysis; en un
</I>&gt;<i> programa ZZZ no hace falta. Si no se tiene el sub procedimiento para
</I>&gt;<i> análisis de alias, todo sigue funcionando. Pero es probable que en los
</I>&gt;<i> programas escritos en YYY se encuentren menos vulnerabilidades.
</I>&gt;<i>
</I>&gt;<i> Esto último es solo una idea intuitiva que tengo, si alguien puede arrojar
</I>&gt;<i> más luz al asunto se lo agradezco. Por otro lado, puede ser que la solución
</I>&gt;<i> de este tipo de problemas/incompatibilidades sea correcto realizarla en el
</I>&gt;<i> paso previo (Normalización). No lo se, no lo veo claro aún.
</I>&gt;<i>
</I>&gt;<i> Me imagino que deben existir otros problemas dependientes del lenguaje que
</I>&gt;<i> requieran de sub procedimientos específicos; agrupo esto en el concepto de
</I>&gt;<i> &quot;modo&quot;. Un modo estaría definido por el conjunto de sub analizadores que
</I>&gt;<i> carga antes de correr.
</I>
No estoy seguro de que demonios quiciste decir acá, pero... creo que
esto se puede solucionar en la etapa de normalización de alguna manera
que no quiero ponerme a pensar ;)

&gt;<i> Este procesamiento puede realizarse mediante Data Flow Analysis (esta
</I>&gt;<i> técnica, es utilizada por Pixy y documentada en [2]).
</I>
Ok,

&gt;<i> También se puede utilizar otra técnica; ¿conocen alguna otra teoría
</I>&gt;<i> aplicable? Otro disparador para investigar.
</I>&gt;<i>
</I>&gt;<i> ¿Qué les parece?
</I>&gt;<i>
</I>&gt;<i> (+) funciones, objetos, lo que sea.
</I>&gt;<i> (*) aquí hay un punto que podemos dejarlo para más adelante: no todas las
</I>&gt;<i> funciones limpiadoras proveen de todas las posibles amenazas. Una función
</I>&gt;<i> que convierte los caracteres &lt; y &gt; en &amp;lt; y &amp;gt; puede prevenir XSS pero no
</I>&gt;<i> SQLI.
</I>
Uuups, creo que leer todo el email antes de ponerme a contestar capaz
es una buena práctica! ;)

hmmm, no lo dejaría para el final, lo metería de lleno, ya que es algo
importante a tener en cuenta y cambia bastante el código.

&gt;<i> [0] Tree-address code; es la única que conozco pero no me convenció aún.
</I>&gt;<i> Abría que buscar otras. Este es un disparador a investigar.
</I>&gt;<i> [1] En Implementation of Tainted Mode approach to finding security
</I>&gt;<i> vulnerabilities for Python technology se plantea cómo implementar un
</I>&gt;<i> análisis dinámico en Python.
</I>&gt;<i> <A HREF="http://syrcose.ispras.ru/2007/files/2007_07_paper.pdf">http://syrcose.ispras.ru/2007/files/2007_07_paper.pdf</A>
</I>&gt;<i> [2] Pixy: A Static Analysis Tool for Detecting Web Application
</I>&gt;<i> Vulnerabilities (Technical Report).
</I>&gt;<i> <A HREF="http://www.seclab.tuwien.ac.at/papers/pixy_techreport.pdf">http://www.seclab.tuwien.ac.at/papers/pixy_techreport.pdf</A>
</I>
Yo estuve investigando como hacer algo de esto, y te dejo un par de
cosas: pyantlr , pyparsing.
Lo bueno de pyparsing es que es pure python, mientras que pyantlr no
lo es. Pero pyantlr tiene un monton de definiciones de lenguajes que
ya se podrían usar de una.

Que emails largos que te gustan escribir eh! ;) Ahora en serio... me
encanta que te hayas copado con esta idea, porque en mi opinión es la
solución a MUCHOS problemas, y todavía no hay un proyecto líder que
este cubriendo esta necesidad en el ambiente open source.

Saludos,

&gt;<i> --
</I>&gt;<i> Juanjo Conti
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Owasp-argentina mailing list
</I>&gt;<i> <A HREF="https://lists.owasp.org/mailman/listinfo/owasp-argentina">Owasp-argentina en lists.owasp.org</A>
</I>&gt;<i> <A HREF="https://lists.owasp.org/mailman/listinfo/owasp-argentina">https://lists.owasp.org/mailman/listinfo/owasp-argentina</A>
</I>&gt;<i>
</I>


-- 
Andrés Riancho
Founder, Bonsai - Information Security
<A HREF="http://www.bonsai-sec.com/">http://www.bonsai-sec.com/</A>
<A HREF="http://w3af.sf.net/">http://w3af.sf.net/</A>
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Mensaje anterior: <A HREF="000162.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
	<LI>Próximo mensaje: <A HREF="000164.html">[Owasp-argentina] Sistema para detectar vulnerabilidades de	variables manchadas
</A></li>
         <LI> <B>Mensajes ordenados por:</B> 
              <a href="date.html#163">[ fecha ]</a>
              <a href="thread.html#163">[ hilo ]</a>
              <a href="subject.html#163">[ asunto ]</a>
              <a href="author.html#163">[ autor ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.owasp.org/mailman/listinfo/owasp-argentina">Más información sobre la lista de distribución Owasp-argentina </a><br>
</body></html>
