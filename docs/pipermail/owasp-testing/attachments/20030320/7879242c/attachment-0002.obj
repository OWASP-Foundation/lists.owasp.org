#!/usr/bin/perl -w

use strict;
use Math::BigInt ':constant';
use Getopt::Std;                       # for command line options
my %opt; # to hold the options
getopts("hcvd:f:o:",\%opt);

if ($opt{'h'}) { 
  print STDERR<<EOH;
Usage: 
  
  cat cookies | ./charset.pl [-c] [-v] [-d "string"] [-f cookiefield] \\
                             [-o field,field] > out.dat

where
  -c indicates that we wish to see the character set for each position
  -v shows progress messages
  -d "string" indicates the string to use to split the input line (default ":")
  -f field indicates which field on the line contains the cookie to analyse
  -o field,field indicates which fields to output, other than the cookie value

EOH
  exit 1;
}

my $progress = 0;
if ($opt{'v'}) { $progress = 1; }

my $charset = 0;
if ($opt{'c'}) { $charset = 1; }

my $cookiefield = 1;
if ($opt{'f'}) { $cookiefield = $opt{'f'}; }

my $separator = ':';
if ($opt{'d'}) { $separator = $opt{'d'}; }

my @outputfields=();
if ($opt{'o'}) { 
  @outputfields = split(',',$opt{'o'}); print "Got ",$#outputfields,"\n";
}

my @lines=();    # holds the lines read in, already split into their fields

my %chars=();    # holds the total character set, and counters

my @charpos=();  # contains character sets per character position, with counters

my $lineno=0;    # tracks progress

while (my $line=<STDIN>) {
  chomp $line;

  # split the line read into its fields
  my @fields = split(/$separator/,$line);
  $lines[$lineno] = \@fields;

  # get the cookie
  my $cookie=$fields[$cookiefield-1];

  if ($progress) { 
    if ($lineno>0) {
      print STDERR "\r";
    }
    print STDERR "Reading $cookie on line $lineno"; 
  }
  
  # split the cookie into individual characters
  my @cookie=split('',$cookie);

  for (my $i=0; $i<=$#cookie; $i++) {
    my $char=$cookie[$i];

    # increment the global character set and counters
    if (! exists $chars{$char} ) {
      $chars{$char}=1;
    } else {
      $chars{$char}++;
    }

    # increment the positional character set and counters
    if (!exists $charpos[$i]->{$char}) {
      $charpos[$i]->{$char}=1;
    } else {
      $charpos[$i]->{$char}++;
    }
  }
  $lineno++;
}

if ($progress) { print STDERR "\n"; }

if ($charset) {
  my @chars=sort keys %chars;
  print STDERR "Overall Character set count is : ",$#chars+1,"\n";
  print STDERR "Overall Character set is : \n";
  print STDERR join('',sort keys %chars),"\n";
  
  print STDERR "\nOverall Distribution is :\n";

  foreach my $char (sort keys %chars) {
    print STDERR "$char : ",$chars{$char},"\n";
  }
}


my @charset;

# if you want to tweak the order of the characters in the set, define them here
# e.g. $charset[1] = ["a","bcd","efg"];

@charset=();


for (my $i=0; $i<=$#charpos; $i++) {
  if ( ! $charset[$i]) {
    $charset[$i]=join("",sort keys %{$charpos[$i]});
  } else {
    $charset[$i] = join("",@{$charset[$i]});
  }
  if ($charset) {
    print STDERR "\$charset[$i] is '",$charset[$i],"'\n";
  }
}

if ($progress) {
  print STDERR "Calculating cookie values\n";
}

for (my $lineno=0; $lineno<=$#lines; $lineno++) {
  my $cookie = $lines[$lineno][$cookiefield-1];
  if ($progress) {
    if ($lineno>0) { print STDERR "\r"; }
    print STDERR "Processing $cookie on $lineno";
  }
  my $total=Math::BigInt->new("0");

  my $l = length($cookie);

  # it would be better to do this from least significant first.
  # That way, if we get a charset that is only 1 character, we don't
  # need to increment the "position" and therefore the base is reduced
  # this already works for chars leading in, but it would be good
  # for it to work with chars in the middle, and at the end as well.

  for ( my $p=0; $p < $l; $p++) {
    my ($value,$base)=charval(substr($cookie,$p,1),$charset[$p]);
    $value = Math::BigInt->new($value);
    $base = Math::BigInt->new($base);
    $base = $base**($l-$p-1);
    $total+=$value*$base;
  }
  if ($#outputfields>-1) {
    foreach my $output (@outputfields) {
      print $lines[$lineno][$output-1]," ";
    }
  } else {
    for (my $j=0; $j<=$#{$lines[$lineno]}; $j++) {
      print $lines[$lineno][$j]," ";
    }
  }
  print $total,"\n";
}

if ($progress) { print STDERR "\n"; }

exit;


sub charval {
  my $char=shift;
  my $charset=shift;

  return (index($charset,$char),length($charset));
}
