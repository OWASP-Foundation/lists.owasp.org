<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Owasp-vancouver] logging question
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:owasp-vancouver%40lists.owasp.org?Subject=Re%3A%20%5BOwasp-vancouver%5D%20logging%20question&In-Reply-To=%3CCADjmq0gdj5SoFrkozekTtq%2B45TD617zQsJY%2B8d4NO78VC4HL_w%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000161.html">
   <LINK REL="Next"  HREF="000163.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Owasp-vancouver] logging question</H1>
    <B>Iain Duncan</B> 
    <A HREF="mailto:owasp-vancouver%40lists.owasp.org?Subject=Re%3A%20%5BOwasp-vancouver%5D%20logging%20question&In-Reply-To=%3CCADjmq0gdj5SoFrkozekTtq%2B45TD617zQsJY%2B8d4NO78VC4HL_w%40mail.gmail.com%3E"
       TITLE="[Owasp-vancouver] logging question">iduncan at xornot.com
       </A><BR>
    <I>Fri Feb  3 18:24:30 UTC 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="000161.html">[Owasp-vancouver] logging question
</A></li>
        <LI>Next message: <A HREF="000163.html">[Owasp-vancouver] logging question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#162">[ date ]</a>
              <a href="thread.html#162">[ thread ]</a>
              <a href="subject.html#162">[ subject ]</a>
              <a href="author.html#162">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks so much for the detailed response Yvan. Some questions and answers
below

&gt;<i>
</I>&gt;<i> I'm implementing some fairly detailed logging for a client, for security
</I>&gt;&gt;<i> and for legal coverage ( non-repudiation of reading disclaimers, etc). The
</I>&gt;&gt;<i> records are being logged to a database, with the goal to convince the
</I>&gt;&gt;<i> client that this db should be moved to a separate server so that logs go
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> a a remote machine for which the app has only insert privileges.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Logging to a remote server is always a good start, but I am curious about
</I>&gt;<i> the decision to store logs in a database rather than a using a conventional
</I>&gt;<i> logging service (syslog or one of its variants, a flat file that gets
</I>&gt;<i> pushed or pulled periodically, etc).  Using a custom format or storing the
</I>&gt;<i> records within a database may make it more difficult to get the data into
</I>&gt;<i> an event processing engine that allows admins of your application to
</I>&gt;<i> correlate application logs against system and network events.
</I>&gt;<i>
</I>
In our case, we're using Pyramid and SQLAlchemy, so the decision to use the
DB was because it make adding our our own event processing logic almost
trivial. It also allows us to have a relational schema for logging that
corresponds somewhat to the logic of the application, and we're logging
application specific details. We may push this layer into WSGI middleware,
not sure about that. Pyramid has some really nice facilities for hooking
into the life cycle of the request, if you make a custom request factory,
you can connect beginning and end of life cycle callbacks. Another design
pattern of Pyramid that is useful for this is the Zope 3 style
views-as-classes, which are multi-adapters of request and context and are
always instantiated, called, and destroyed once per request ( no shared
state between threads at all). A happy side effect of this is that it's
safe to store your intermediate results of what the view is doing as
attributes on the view. We do this, and we store the a ref to the view on
the request object itself. This means that the end of life callback can
introspect the view to figure out exactly what went on during this request.

The main driver for the logging is the non-repudiation, so by logging the
http request, we collect user id, time, ip, url, etc, but this gets
connected to entries that log file downloads, file uploads, reading the
disclaimers, editing the user accounts, and activating the user accounts.
Those all have their own schemas, but that is quite easy to implement on
the framework we're using. So by putting it the db, it's very easy for us
to provide the client ( and their legal counsel ) a record that shows they
did their due diligence in making sure that users read the terms and
conditions before uploading, etc. Hopefully that clarifies that design
decision.


&gt;<i> One of the logs is of each request for a pyramid view ( essentially any
</I>&gt;&gt;<i> kind of
</I>&gt;&gt;<i> complete page, does not include requests for css/javascript/images ). I
</I>&gt;&gt;<i> had
</I>&gt;&gt;<i> read that it's a good idea to just log the whole http request, but of
</I>&gt;&gt;<i> course that has the session token in it.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In general, logging the entire HTTP request outside of a debug environment
</I>&gt;<i> is unsafe since you invariably end up storing user credentials, session
</I>&gt;<i> state data, and other sensitive data outside of the application and its
</I>&gt;<i> database.  Best case scenario, this is a violation of best practice, worst
</I>&gt;<i> case scenario it is a regulatory or compliance issue.  If you go that
</I>&gt;<i> route, make sure you are properly sanitizing the fields that contain
</I>&gt;<i> sensitive data before writing them to the database.
</I>&gt;<i>
</I>
Is wiping out the cookies header and any password fields sufficient for
this?

I was thinking about attack awareness, and thought that monitoring POST
vars would be good, because then one can detect repeated attempts to fudge
them. But then we must be careful never to log any of the password
submission variables.


&gt;<i>
</I>&gt;&gt;<i> I'm just wondering whether I should be concerned about the fact that if a
</I>&gt;&gt;<i> compromise allowed someone to
</I>&gt;&gt;<i> read the db, could they hijack an admin users session?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In general, yes.  Note that in this case, you should be extending beyond
</I>&gt;<i> the consideration of an external attacker and consider what a malicious
</I>&gt;<i> user might be able to accomplish.  If your authentication scheme is
</I>&gt;<i> designed properly, and you have proper separation of duties within your
</I>&gt;<i> environment, a system administrator or DBA should not be able to violate
</I>&gt;<i> the non-repudiation aspect of the design without resorting to collusion.
</I>&gt;<i>
</I>
Great, thanks.


&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Which has me trying to figure out if that matters, given that if they can
</I>&gt;&gt;<i> read the db, they're pretty far in. I could redact the session token ( and
</I>&gt;&gt;<i> all cookies ) before logging, but would this have potential negatives for
</I>&gt;&gt;<i> forensics?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Generating a proper audit trail extends beyond capturing the content of an
</I>&gt;<i> HTTP request; it would be more effective to generate an audit record of
</I>&gt;<i> every privileged action a user performs (or, if necessary, of every action
</I>&gt;<i> performed).  Generating this type of an audit capability serves two
</I>&gt;<i> purposes:
</I>&gt;<i>
</I>&gt;<i> First, it lets you meet any requirements you might have around executing
</I>&gt;<i> application level forensics of what happened.  Having discrete, clearly
</I>&gt;<i> documented, and granular audit capabilities make it clear which subject
</I>&gt;<i> performed with operation on which object, and the context in which that
</I>&gt;<i> operation performed, without having to sift through HTTP request blobs in
</I>&gt;<i> log files.
</I>&gt;<i>
</I>&gt;<i>
</I>Right, that's what we're accomplishing through the related schema of http
requests to user actions.


&gt;<i> Second, it provides data that can be used to make an application attack
</I>&gt;<i> aware, which increases the likelihood of detecting and stopping an attack
</I>&gt;<i> or compromise.
</I>&gt;<i>
</I>&gt;<i> You can read more about attack aware applications here:
</I>&gt;<i>  - <A HREF="https://www.owasp.org/index.php/OWASP_AppSensor_Project">https://www.owasp.org/index.php/OWASP_AppSensor_Project</A> (especially
</I>&gt;<i> the detection points)
</I>&gt;<i>  - <A HREF="http://blog.mozilla.com/webappsec/2011/02/02/attack-aware-applications/">http://blog.mozilla.com/webappsec/2011/02/02/attack-aware-applications/</A>
</I>&gt;<i>  - Mozilla's AMO uses CEF logging to implement attack awareness if you
</I>&gt;<i> want some examples of how to do this in python (although that is specific
</I>&gt;<i> to our use of Arcsight)
</I>&gt;<i>
</I>&gt;<i>
</I>
I am planning on looking further into that, Python's WSGI system is ideal
for this as the middleware layer before the application can access the same
db, look at the log events, and make decisions on allowing/disallowing
incoming requests before any of the main application logic is even
called.  I will definitely take a look at those!

And thanks again for the detailed response.

Iain
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000161.html">[Owasp-vancouver] logging question
</A></li>
	<LI>Next message: <A HREF="000163.html">[Owasp-vancouver] logging question
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#162">[ date ]</a>
              <a href="thread.html#162">[ thread ]</a>
              <a href="subject.html#162">[ subject ]</a>
              <a href="author.html#162">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.owasp.org/mailman/listinfo/owasp-vancouver">More information about the Owasp-vancouver
mailing list</a><br>
</body></html>
